{"remainingRequest":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js??ref--9-1!/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js??ref--9-2!/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/timelion/public/panels/timechart/schema.js","dependencies":[{"path":"/home/anthony/git_workspaces/kibana/src/legacy/core_plugins/timelion/public/panels/timechart/schema.js","mtime":1567631691300},{"path":"/home/anthony/git_workspaces/kibana/node_modules/cache-loader/dist/cjs.js","mtime":1567666236302},{"path":"/home/anthony/git_workspaces/kibana/node_modules/thread-loader/dist/cjs.js","mtime":1567666239443},{"path":"/home/anthony/git_workspaces/kibana/node_modules/babel-loader/lib/index.js","mtime":1567666227676}],"contextDependencies":[],"result":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = timechartFn;\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _jquery = require('jquery');\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _momentTimezone = require('moment-timezone');\n\nvar _momentTimezone2 = _interopRequireDefault(_momentTimezone);\n\nvar _observe_resize = require('../../lib/observe_resize');\n\nvar _observe_resize2 = _interopRequireDefault(_observe_resize);\n\nvar _lib = require('../../../common/lib');\n\nvar _timefilter = require('ui/timefilter');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nrequire('./flot');\n\n\nvar DEBOUNCE_DELAY = 50;\n\nfunction timechartFn(Private, config, $rootScope, $compile) {\n  return function () {\n    return {\n      help: 'Draw a timeseries chart',\n      render: function render($scope, $elem) {\n        var template = '<div class=\"chart-top-title\"></div><div class=\"chart-canvas\"></div>';\n        var tickFormatters = require('plugins/timelion/services/tick_formatters')();\n        var getxAxisFormatter = Private(require('plugins/timelion/panels/timechart/xaxis_formatter'));\n        var generateTicks = Private(require('plugins/timelion/panels/timechart/tick_generator'));\n\n        // TODO: I wonder if we should supply our own moment that sets this every time?\n        // could just use angular's injection to provide a moment service?\n        _momentTimezone2.default.tz.setDefault(config.get('dateFormat:tz'));\n\n        var render = $scope.seriesList.render || {};\n\n        $scope.chart = $scope.seriesList.list;\n        $scope.interval = $scope.interval;\n        $scope.search = $scope.search || _lodash2.default.noop;\n\n        var legendValueNumbers = void 0;\n        var legendCaption = void 0;\n        var debouncedSetLegendNumbers = _lodash2.default.debounce(setLegendNumbers, DEBOUNCE_DELAY, {\n          maxWait: DEBOUNCE_DELAY,\n          leading: true,\n          trailing: false\n        });\n        // ensure legend is the same height with or without a caption so legend items do not move around\n        var emptyCaption = '<br>';\n\n        var defaultOptions = {\n          xaxis: {\n            mode: 'time',\n            tickLength: 5,\n            timezone: 'browser'\n          },\n          selection: {\n            mode: 'x',\n            color: '#ccc'\n          },\n          crosshair: {\n            mode: 'x',\n            color: '#C66',\n            lineWidth: 2\n          },\n          grid: {\n            show: render.grid,\n            borderWidth: 0,\n            borderColor: null,\n            margin: 10,\n            hoverable: true,\n            autoHighlight: false\n          },\n          legend: {\n            backgroundColor: 'rgb(255,255,255,0)',\n            position: 'nw',\n            labelBoxBorderColor: 'rgb(255,255,255,0)',\n            labelFormatter: function labelFormatter(label, series) {\n              var wrapperSpan = document.createElement('span');\n              var labelSpan = document.createElement('span');\n              var numberSpan = document.createElement('span');\n\n              wrapperSpan.setAttribute('class', 'ngLegendValue');\n              wrapperSpan.setAttribute('kbn-accessible-click', '');\n              wrapperSpan.setAttribute('ng-click', 'toggleSeries(' + series._id + ')');\n              wrapperSpan.setAttribute('ng-focus', 'focusSeries(' + series._id + ')');\n              wrapperSpan.setAttribute('ng-mouseover', 'highlightSeries(' + series._id + ')');\n\n              labelSpan.setAttribute('ng-non-bindable', '');\n              labelSpan.appendChild(document.createTextNode(label));\n              numberSpan.setAttribute('class', 'ngLegendValueNumber');\n\n              wrapperSpan.appendChild(labelSpan);\n              wrapperSpan.appendChild(numberSpan);\n\n              return wrapperSpan.outerHTML;\n            }\n          },\n          colors: ['#01A4A4', '#C66', '#D0D102', '#616161', '#00A1CB', '#32742C', '#F18D05', '#113F8C', '#61AE24', '#D70060']\n        };\n\n        var originalColorMap = new Map();\n        $scope.chart.forEach(function (series, seriesIndex) {\n          if (!series.color) {\n            var colorIndex = seriesIndex % defaultOptions.colors.length;\n            series.color = defaultOptions.colors[colorIndex];\n          }\n          originalColorMap.set(series, series.color);\n        });\n\n        var highlightedSeries = void 0;\n        var focusedSeries = void 0;\n        function unhighlightSeries() {\n          if (highlightedSeries === null) {\n            return;\n          }\n\n          highlightedSeries = null;\n          focusedSeries = null;\n          $scope.chart.forEach(function (series) {\n            series.color = originalColorMap.get(series); // reset the colors\n          });\n          drawPlot($scope.chart);\n        }\n        $scope.highlightSeries = _lodash2.default.debounce(function (id) {\n          if (highlightedSeries === id) {\n            return;\n          }\n\n          highlightedSeries = id;\n          $scope.chart.forEach(function (series, seriesIndex) {\n            if (seriesIndex !== id) {\n              series.color = 'rgba(128,128,128,0.1)'; // mark as grey\n            } else {\n              series.color = originalColorMap.get(series); // color it like it was\n            }\n          });\n          drawPlot($scope.chart);\n        }, DEBOUNCE_DELAY);\n        $scope.focusSeries = function (id) {\n          focusedSeries = id;\n          $scope.highlightSeries(id);\n        };\n\n        $scope.toggleSeries = function (id) {\n          var series = $scope.chart[id];\n          series._hide = !series._hide;\n          drawPlot($scope.chart);\n        };\n\n        var cancelResize = (0, _observe_resize2.default)($elem, function () {\n          drawPlot($scope.chart);\n        });\n\n        $scope.$on('$destroy', function () {\n          cancelResize();\n          $elem.off('plothover');\n          $elem.off('plotselected');\n          $elem.off('mouseleave');\n        });\n\n        $elem.on('plothover', function (event, pos, item) {\n          $rootScope.$broadcast('timelionPlotHover', event, pos, item);\n        });\n\n        $elem.on('plotselected', function (event, ranges) {\n          _timefilter.timefilter.setTime({\n            from: (0, _momentTimezone2.default)(ranges.xaxis.from),\n            to: (0, _momentTimezone2.default)(ranges.xaxis.to),\n            mode: 'absolute'\n          });\n        });\n\n        $elem.on('mouseleave', function () {\n          $rootScope.$broadcast('timelionPlotLeave');\n        });\n\n        $scope.$on('timelionPlotHover', function (angularEvent, flotEvent, pos) {\n          if (!$scope.plot) return;\n          $scope.plot.setCrosshair(pos);\n          debouncedSetLegendNumbers(pos);\n        });\n\n        $scope.$on('timelionPlotLeave', function () {\n          if (!$scope.plot) return;\n          $scope.plot.clearCrosshair();\n          clearLegendNumbers();\n        });\n\n        // Shamelessly borrowed from the flotCrosshairs example\n        function setLegendNumbers(pos) {\n          unhighlightSeries();\n\n          var plot = $scope.plot;\n\n          var axes = plot.getAxes();\n          if (pos.x < axes.xaxis.min || pos.x > axes.xaxis.max) {\n            return;\n          }\n\n          var i = void 0;\n          var j = void 0;\n          var dataset = plot.getData();\n          if (legendCaption) {\n            legendCaption.text((0, _momentTimezone2.default)(pos.x).format(_lodash2.default.get(dataset, '[0]._global.legend.timeFormat', _lib.DEFAULT_TIME_FORMAT)));\n          }\n          for (i = 0; i < dataset.length; ++i) {\n\n            var series = dataset[i];\n            var precision = _lodash2.default.get(series, '_meta.precision', 2);\n\n            if (series._hide) continue;\n\n            // Nearest point\n            for (j = 0; j < series.data.length; ++j) {\n              if (series.data[j][0] > pos.x) break;\n            }\n\n            var y = void 0;\n            try {\n              y = series.data[j][1];\n            } catch (e) {\n              y = null;\n            }\n\n            if (y != null) {\n              var label = y.toFixed(precision);\n              if (series.yaxis.tickFormatter) {\n                label = series.yaxis.tickFormatter(label, series.yaxis);\n              }\n              legendValueNumbers.eq(i).text('(' + label + ')');\n            } else {\n              legendValueNumbers.eq(i).empty();\n            }\n          }\n        }\n\n        function clearLegendNumbers() {\n          if (legendCaption) {\n            legendCaption.html(emptyCaption);\n          }\n          _lodash2.default.each(legendValueNumbers, function (num) {\n            (0, _jquery2.default)(num).empty();\n          });\n        }\n\n        var legendScope = $scope.$new();\n        function drawPlot(plotConfig) {\n          if (!(0, _jquery2.default)('.chart-canvas', $elem).length) $elem.html(template);\n          var canvasElem = (0, _jquery2.default)('.chart-canvas', $elem);\n\n          // we can't use `$.plot` to draw the chart when the height or width is 0\n          // so, we'll need another event to trigger drawPlot to actually draw it\n          if (canvasElem.height() === 0 || canvasElem.width() === 0) {\n            return;\n          }\n\n          var title = (0, _lodash2.default)(plotConfig).map('_title').compact().last();\n          (0, _jquery2.default)('.chart-top-title', $elem).text(title == null ? '' : title);\n\n          var options = _lodash2.default.cloneDeep(defaultOptions);\n\n          // Get the X-axis tick format\n          var time = _timefilter.timefilter.getBounds();\n          var interval = (0, _lib.calculateInterval)(time.min.valueOf(), time.max.valueOf(), config.get('timelion:target_buckets') || 200, $scope.interval, config.get('timelion:min_interval') || '1ms');\n          var format = getxAxisFormatter(interval);\n\n          // Use moment to format ticks so we get timezone correction\n          options.xaxis.tickFormatter = function (val) {\n            return (0, _momentTimezone2.default)(val).format(format);\n          };\n\n          // Calculate how many ticks can fit on the axis\n          var tickLetterWidth = 7;\n          var tickPadding = 45;\n          options.xaxis.ticks = Math.floor($elem.width() / (format.length * tickLetterWidth + tickPadding));\n\n          var series = _lodash2.default.map(plotConfig, function (series, index) {\n            series = _lodash2.default.cloneDeep(_lodash2.default.defaults(series, {\n              shadowSize: 0,\n              lines: {\n                lineWidth: 3\n              }\n            }));\n            series._id = index;\n\n            if (series.color) {\n              var span = document.createElement('span');\n              span.style.color = series.color;\n              series.color = span.style.color;\n            }\n\n            if (series._hide) {\n              series.data = [];\n              series.stack = false;\n              //series.color = \"#ddd\";\n              series.label = '(hidden) ' + series.label;\n            }\n\n            if (series._global) {\n              _lodash2.default.merge(options, series._global, function (objVal, srcVal) {\n                // This is kind of gross, it means that you can't replace a global value with a null\n                // best you can do is an empty string. Deal with it.\n                if (objVal == null) return srcVal;\n                if (srcVal == null) return objVal;\n              });\n            }\n\n            return series;\n          });\n\n          if (options.yaxes) {\n            options.yaxes.forEach(function (yaxis) {\n              if (yaxis && yaxis.units) {\n                yaxis.tickFormatter = tickFormatters[yaxis.units.type];\n                var byteModes = ['bytes', 'bytes/s'];\n                if (byteModes.includes(yaxis.units.type)) {\n                  yaxis.tickGenerator = generateTicks;\n                }\n              }\n            });\n          }\n\n          $scope.plot = _jquery2.default.plot(canvasElem, _lodash2.default.compact(series), options);\n\n          if ($scope.plot) {\n            $scope.$emit('timelionChartRendered');\n          }\n\n          legendScope.$destroy();\n          legendScope = $scope.$new();\n          // Used to toggle the series, and for displaying values on hover\n          legendValueNumbers = canvasElem.find('.ngLegendValueNumber');\n          _lodash2.default.each(canvasElem.find('.ngLegendValue'), function (elem) {\n            $compile(elem)(legendScope);\n          });\n\n          if (_lodash2.default.get($scope.plot.getData(), '[0]._global.legend.showTime', true)) {\n            legendCaption = (0, _jquery2.default)('<caption class=\"timChart__legendCaption\"></caption>');\n            legendCaption.html(emptyCaption);\n            canvasElem.find('div.legend table').append(legendCaption);\n\n            // legend has been re-created. Apply focus on legend element when previously set\n            if (focusedSeries || focusedSeries === 0) {\n              var $legendLabels = canvasElem.find('div.legend table .legendLabel>span');\n              $legendLabels.get(focusedSeries).focus();\n            }\n          }\n        }\n        $scope.$watch('chart', drawPlot);\n      }\n    };\n  };\n}\nmodule.exports = exports['default'];",null]}